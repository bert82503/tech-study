

Java 8新特性探究（一）通往lambda之路_语法篇
======


说到Java 8，首先会想到**lambda（闭包）以及虚拟扩展方法（default method）**，
也是我们java 8系列开篇要讲的第一特性（JEP126 http://openjdk.java.net/jeps/126），
jdk8的一些库已经应用了**lambda表达式**重新设计，**理解她对学习java 8新特性有着重要的意义**。

现在开始要灌输一些概念性的东西了，这能帮助你理解lambda更加透彻一点。
如果你之前听说过，也可当是温习，所谓温故而知新。


# 函数式接口
函数式接口（functional interface 也叫功能性接口）。简单来说，**函数式接口是只包含一个方法的接口。**
比如Java标准库中的java.lang.Runnable和java.util.Comparator都是典型的函数式接口。
Java 8提供@FunctionalInterface作为注解，这个注解是非必须的，只要接口符合函数式接口的标准（即只包含一个方法的接口），虚拟机会自动判断。
但最好在接口上使用注解@FunctionalInterface进行声明，以免团队的其他人员错误地往接口中添加新的方法。

Java中的lambda无法单独出现，它需要一个函数式接口来盛放，**lambda表达式方法体其实就是函数接口的实现**，下面讲到语法会讲到。


# Lambda语法
包含三个部分：
* 一个括号内用逗号分隔的**形式参数**，参数是函数式接口里面方法的参数
* 一个**箭头符号**：->
* **方法体**，可以是表达式和代码块，方法体函数式接口里面方法的实现。
  如果是代码块，则必须用{}来包裹起来，且需要一个return返回值。
  但有个例外，若函数式接口里面方法返回值是void，则无需{}。

总体看起来像这样：
```
(parameters) -> expression 或者 (parameters) -> { statements; }
```

可以看出，**使用lambda表达式设计的代码会更加简洁，而且还可读。**


# 方法引用
其实是lambda表达式的一个简化写法，**所引用的方法其实是lambda表达式的方法体实现。**
**语法**也很简单，左边是**容器**（可以是类名，实例名），中间是”::”，右边是**相应的方法名**。
如下所示：
```
ObjectReference::methodName 
```

一般**方法的引用**格式是
1. 如果是**静态方法**，则是ClassName::methodName。如Object::equals
2. 如果是**实例方法**，则是Instance::methodName。如Object obj=new Object();obj::equals;
3. **构造函数**，则是ClassName::new

可以看出，doSomething方法就是lambda表达式的实现。
**这样的好处就是，如果你觉得lambda的方法体会很长，影响代码可读性，方法引用就是个解决办法。**


# 总结
以上就是lambda表达式语法的全部内容，相信大家对lambda表达式都有一定的理解了。
但只是**代码简洁了**这个好处的话，并不能打动很多观众，java 8也不会这么令人期待。
**其实java 8引入lambda的迫切需求是因为lambda表达式能简化集合上数据的多线程或者多核的处理，提供更快的集合处理速度。**
这个后续会讲到，关于JEP126的这一特性，将分3部分，之所以分开是因为这一特性可写的东西太多了。
这部分让读者熟悉**lambda表达式以及方法引用的语法和概念**，第二部分则是**虚拟扩展方法（default method）**的内容，
最后一部分则是**大数据集合的处理，解开lambda表达式的最强作用的神秘面纱。**

