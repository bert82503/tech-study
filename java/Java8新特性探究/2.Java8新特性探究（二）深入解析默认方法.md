

Java 8新特性探究（二）深入解析默认方法
======
> https://my.oschina.net/benhaile/blog/176007


上篇讲了**lambda表达式的语法**，但只是 [JEP126](https://openjdk.org/projects/jdk8/features) 特性的一部分，
另一部分就是**默认方法**（也称为**虚拟扩展方法**或防护方法）。


# 什么是默认方法，为什么要有默认方法
**默认方法就是接口可以有实现方法**，而且不需要实现类去实现其方法。只需在方法名前面加个**default**关键字即可。

**为什么要有这个特性？**
首先，之前的接口是个双刃剑，好处是面向**抽象**而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类。
目前**java 8之前的集合框架没有foreach方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。**
然而，对于已经发布的版本，是没法再给接口添加新方法的同时不影响已有的实现。
所以**引进默认方法，目的是为了解决接口的修改与现有的实现不兼容的问题。**


# Java 8抽象类与接口对比
这一个功能特性出来后，很多同学都反应了，**java 8的接口都有实现方法了，跟抽象类还有什么区别？**
其实还是有的，请看下表对比。

相同点
1. 都是**抽象类型**
2. 都可以有实现方法（以前接口不行）
3. 都可以不需要实现类或者继承者去实现所有方法（以前不行，现在接口中默认方法不需要实现者实现）

不同点
1. 抽象类不可以多重继承，接口可以（无论是多重类型继承还是多重行为继承）
2. **抽象类和接口所反映出的设计理念不同**。其实抽象类表示的是"is-a"关系，接口表示的是"like-a"关系
3. 接口中定义的变量默认是public static final型，且必须给其初值，所以实现类中不能改变其值；
   抽象类中的变量默认是friendly型，其值可以在子类中重新定义，也可以重新赋值


# 多重继承的冲突说明
由于同一个方法可以从不同接口引入，自然而然的会有冲突的现象，默认方法判断冲突的规则如下：
1. 一个声明在类里面的方法优先于任何默认方法（classes always win）
2. 否则，则会优先选取最具体的实现。


# 总结
**默认方法给予我们修改接口而不破坏原来的实现类的结构提供了便利，目前java 8的集合框架已经大量使用了默认方法来改进。
当我们最终开始使用Java 8的lambdas表达式时，提供给我们一个平滑的过渡体验。**
也许将来我们会在API设计中看到更多的默认方法的应用。

跟上篇博文结合起来，就是JEP126的全部了，后面还有54个特性等着我们去探究。为了让大家比较深刻了解lambda，学以致用。
下一篇还是lambda的内容，预告一下下篇的标题是《Java 8新特性探究（三）解开lambda最强作用的神秘面纱》，
第二个特性将从第四篇开始，谢谢大家支持，敬请期待。

