

JVM内存区域划分-Eden、Survivor、Tenured
===============================
> 小样，2014-12-03

JVM区域总体分两类，heap区和非heap区。
**Heap区**又分：**Eden Space/伊甸园、Survivor Space/幸存者区、Tenured Gen/老年代-养老区**。
**非heap区**又分：Code Cache/代码缓存区、Perm Gen/永久代、JVM Stack/虚拟机栈、Local Method Stack/本地方法栈。

![JVM memory space](images/7.1.JVM-memory-space.jpg)

HotSpot虚拟机**GC算法**采用**分代收集算法**：
1. 一个人（对象）出来（new）后会在**Eden Space(伊甸园)**无忧无虑的生活，直到`GC`到来打破了他们平静的生活。
   GC会逐一问清楚每个对象的情况，有没有`钱（此对象的引用）`啊，因为GC想`赚钱`呀，有钱的才可以`敲诈`嘛。
   然后`富人`就会进入**Survivor Space(幸存者区)**，`穷人`的就直接`kill掉`。
2. 并不是进入**Survivor Space(幸存者区)**后就保证人身是安全的，但至少可以活段时间。
   GC会定期（可以自定义）会对这些人进行敲诈，`亿万富翁`每次都给钱，GC很满意，就让其进入了**Tenured Gen(养老区)**。
   `万元户`经不住几次敲诈就没钱了，GC看没有啥价值啦，就直接`kill掉`了。
3. 进入到**养老区**的人基本就可以保证`人身安全`啦，但是亿万富豪有的也会挥霍成穷光蛋，只要钱没了，GC还是kill掉。

【生动有趣的类比小故事】

**分区的目的**：**新生区**由于`对象产生的比较多并且大多是朝生夕灭的`，所以直接采用**复制算法**；
而**养老区**`生命力很强`，则采用**标记-清理算法**。针对不同情况使用不同算法。

非heap区域中**Perm Gen**中放着`类、方法的定义`，**JVM Stack**区域放着`方法参数、局域变量等的引用`，方法执行顺序按照栈的先入后出方式。


## 现代JVM内存管理方法及GC的实现和主要思路
**谨以此文纪念已经辞世的C语言之父，Dennis Ritchie。
无论世事如何变迁，无论日月如何更替，您的光辉成就都照耀着现代计算机技术发展之路。**

提到**现代JVM内存管理**，就不能不提到一个意义深远的东西，**C语言**。
C语言最为人诟病，但是也是C语言最让人神往的，就是它的**内存管理机制**。
在C语言中，程序员可以自由的控制内存，自己决定内存里写0还是写1。
所谓的数据类型转换，在C语言看来，不过就是内存里的几次复制以及排列位置的不同，仅此而已。

然而随着应用规模的不断增大，无论是盘根错节的对象耦合关系，还是巨大的内存使用量，都让开发人员麻爪。
动辄几个GB的内存总量，动辄成千上万的内存对象数量，都不再是一个人乃至十个人可以控制的范围了。
况且，`百密一疏，只要有一点点内存泄露，随着时间的推移，都有可能变成无比的灾难。`
OOM之类的问题，在程序员眼里，早已经是家常便饭，谁还没溢出过内存呢，是吧。

的确是有高手可以控制好内存，但是不是所有人。
那么，`大规模团队化开发的时候，如何保证内存使用不出现问题呢？`
代码走查？人工校验？反复测试？这些能不能行的通先不谈，就算可行，
巨大的工作量也可以让所有合同超期到下个世纪。于是有人提出了**一个想法：
可以不可以让一部分高手写出完善的内存管理模块，再加上一堆各式各样的类库和标准，最后构成一个庞大的运行时？**

这一想法被无数语言团队采用。第一个实现的，就是James Gosling领导的Java团队。
**Java的目标是`Write Once, Run Anywhere`。**
估计他们在咖啡馆喝咖啡的时候一时写错了，应该是Debug Anywhere，这才符合现在的实际，呵呵。
扯远了，我们回头看**内存管理**。

JVM提供了很多类库，封装了很多数据类型和常用工具类，作为自己的基本库来使用，比如`java.lang`包。
举一个最简单的例子，来一句最简单的代码。
```java
int i = 5;
```

在C语言里，这句话申请了几个字节的内存，然后放了个5进去，Java也是这么搞的。
只不过，C语言里申请了以后要自己管理，而Java你不用自己烦恼这个事情，虚拟机会帮你处理。
它会判断何时需要，何时不需要。由此推开去更加复杂的业务，比如连接数据库，读取文件，
**我们要做的只是调用类库而已，内存申请和释放都由虚拟机全盘接管，我们不用动一根手指头。**

我们是爽了，虚拟机就头疼了。`这么多对象，什么时候该销毁，什么时候该保持，什么时候要检查这些关系呢？`
在JVM里，这个事情由一个模块来做，也就是我们这片文章的主角，**GC，Garbage Collection，垃圾回收**。

假设我们是实现GC的程序员，那么我们要做什么呢？
首先，负责`分配内存`，负责`控制对象的持有计数`，负责`销毁内存对象`，还得负责`内存整理`什么的。
在Sun制定的**JVM规范**里，`详细描述了GC部分要做的事情`，这里就不赘述了，想看的话，请自行Google。

现有的JVM，主流的，分别是**HotSpot**和**JRockit**，主要研究对象也是这两个。
这篇文章里，我们只研究HotSpot，也就是所谓的Sun JVM。目前阶段，`Sun的GC方式主要有CMS和G1两种`。
`考虑到效果和实际应用`，这里只介绍`CMS`。

CMS，全称**Concurrent Low Pause Collector**，是JDK 1.4后期版本开始引入的新`GC算法`，在JDK 5和6中得到了进一步改进，
它的**主要适合场景是对`响应时间`的重要性需求较高的应用，并且预期这部分应用能够承受垃圾回收线程和应用线程共享处理器资源，且应用中存在比较多的长生命周期的对象的应用。**
CMS是用于`对Tenured Generation的回收`，也就是`年老代的回收`，
**目标是尽量减少`应用的暂停时间`，减少Full GC发生的几率，利用和应用线程并发的`垃圾回收线程`来`标记清除年老代`。**

JVM在程序运行过程当中，会创建大量的对象。`【特征】这些对象，大部分是短周期的对象，小部分是长周期的对象。`
对于`短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉`；
对于`长周期的对象，则不需要频率垃圾回收以确保无谓地垃圾扫描检测`。
**为解决这种矛盾，Sun JVM的内存管理采用`分代的策略`。**

1）**年轻代(Young Gen)**：年轻代主要存放`新创建的对象`，内存大小相对会比较小，垃圾回收会比较频繁。
`年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）`。
当`对象`在堆上`创建`时，将进入`年轻代的Eden Space`。
垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，
如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制到Old Gen。
同时，在扫描Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个`持久化对象`，则将其移到`Old Gen`。
扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色
（即下次垃圾回收时会扫描Eden Space和B Suvivor Space）。这么做主要是为了`减少内存碎片的产生`。
我们可以看到：**Young Gen垃圾回收时，采用`将存活对象复制到空的Suvivor Space`的方式来`确保尽量不存在内存碎片`**，
采用`空间换时间`的方式来加速内存中不再被持有的对象尽快能够得到回收。

2）**年老代(Tenured Gen)**：年老代主要存放JVM认为`生命周期比较长的对象`（经过几次的Young Gen垃圾回收后仍然存在），
内存大小相对会比较大，垃圾回收也相对没有那么频繁（譬如可能几个小时一次）。
年老代主要采用`压缩的方式`来`避免内存碎片`（`将存活对象移动到内存片的一边`，也就是`内存整理`）。
当然，有些垃圾回收器（譬如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。

3）**持久代(Perm Gen)**：持久代主要存放`类定义、字节码和常量等很少会变更的信息`。


[原文](https://my.oschina.net/u/175660/blog/351702)

