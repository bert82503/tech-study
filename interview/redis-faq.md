

Redis面试题总结
======

### 为什么要用Redis缓存？
主要从"高性能"和"高并发"这两点来看待这个问题。
高性能：
访问内存数据，数据更新后回写内存。
高并发：

### Redis底层实现
1.支持丰富的数据类型对象。
2.支持数据的持久化
3.集群模式
4.使用单进程的IO多路复用模型。

### Redis数据结构及使用场景
1.string-字符串对象
计数器：微博数，粉丝数，未读数等
2.hash-哈希表对象
特别适合用于存储对象，用户信息，商品信息等。
3.list-列表对象
微博的关注列表，粉丝列表，消息列表等
高性能分页查询
4.set-集合对象
共同关注，共同粉丝，共同喜好等。
5.sorted set-有序集合对象
在线用户列表，各种礼物排行榜，弹幕消息等

### Redis设置过期时间
任何键key都要设置一个过期时间。
怎么对key进行删除的？**定期删除+惰性删除。**
**定期删除**：Redis默认是每隔100ms就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。
为什么要随机呢？你想一想假如Redis存了几十万个key，每隔100ms就遍历所有设置过期时间的key的话，会给CPU带来很大的负载。
**惰性删除**：定期删除可能会导致很多过期key到了时间并没有被删除掉，所以就有了惰性删除。
假如你的过期key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个key，才会被Redis给删除掉。这就是所谓的惰性删除。

但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？
如果大量过期key堆积在内存里，导致Redis内存块耗尽了。怎么解决这个问题呢？
**Redis内存淘汰机制**。
6种数据淘汰策略：
1.**volatile-lru**：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
2.volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰
3.volatile-random：从已设置过期时间的数据集中任意选择数据淘汰
4.**allkeys-lru**：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key (这个是最常用的)
5.allkeys-random：从数据集中任意选择数据淘汰
6.no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。 (这个应该没人使用吧！)

### 缓存雪崩和缓存穿透问题解决方案
#### 缓存雪崩
缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法：
* 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
* 事中：本地缓存 + hystrix限流&降级，避免MySQL崩掉
* 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

#### 缓存穿透
一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。
解决办法：
有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，
将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，
从而避免了对底层存储系统的查询压力。
另外也有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），
我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。

### 如何解决 Redis 的并发竞争 key 问题
所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，
但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。
（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。
大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。
判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。
同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

在实践中，当然是从以可靠性为主。所以首推Zookeeper。

### 如何保证缓存与数据库双写时的数据一致性？
你只要用缓存，就可能会涉及到缓存与数据库双存储双写，
你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，
缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，
读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

还有一种方式就是可能会暂时产生不一致的情况，但是发生的几率特别小，就是**先更新数据库，然后再删除缓存。**

**这种情况不存在并发问题么？**

不是的。假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生：

（1）缓存刚好失效
（2）请求A查询数据库，得一个旧值
（3）请求B将新值写入数据库
（4）请求B删除缓存
（5）请求A将查到的旧值写入缓存

ok，如果发生上述情况，确实是会发生脏数据。

**如何解决上述并发问题？**

首先，给缓存设置有效时间是一种方案。其次，采用异步延时删除策略，保证读请求完成以后，再进行删除操作。


> [Redis面试题总结（超详细）](https://cloud.tencent.com/developer/article/1899679)
> [20道Redis经典面试题！（珍藏版）](https://zhuanlan.zhihu.com/p/427496556)

### Redis应用场景（可以用来做什么）
> 可用于缓存，事件发布或订阅，高速队列等场景

* 会话缓存（最常用）
* 消息队列（支付）
* 活动排行榜或计数
* 发布，订阅消息（消息通知）
* 商品列表，评论列表

### 为什么使用Redis
* 完全基于内存，数据存在内存中，绝大部分请求是纯粹的内存操作，非常快速，跟传统的磁盘文件数据存储相比，避免了通过磁盘IO读取到内存这部分的开销。
* 数据结构简单，对数据操作也简单。Redis中的数据结构是专门进行设计的，每种数据结构都有一种或多种数据结构来支持。Redis正是依赖这些灵活的数据结构，来提升读取和写入的性能。
* 采用单线程，省去了很多上下文切换的时间以及CPU消耗，不存在竞争条件，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不会出现死锁而导致的性能消耗。
* 使用基于IO多路复用机制的线程模型，可以处理并发的链接。

### 雪崩
#### 雪崩概念
如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上面，导致数据库压力巨大，
如果在高并发的情况下，可能瞬间就会导致数据库宕机。
这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。
这就是**缓存雪崩**。

#### 为什么会发生雪崩
* 第一种是Redis宕机
* 第二种可能就是采用了相同的过期时间

#### 雪崩解决方案
* 事前     
  * 均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。
  * 分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。
  * 热点数据缓存永远不过期
  * 保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况
* 事中     
  * 互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
  * 使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。
* 事后：     
  * 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。

永不过期实际包含两层意思：
* 物理不过期，针对热点key不设置过期时间
* 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建

### 击穿
#### 击穿概念
缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，
大并发集中对其进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。
这种现象就叫做**缓存击穿**。

#### 为什么会发生击穿
关键在于某个热点的key失效了，导致大并发集中打在数据库上。

#### 解决方向
* 第一是否可以考虑热点key不设置过期时间
* 第二是否可以考虑降低打在数据库上的请求数量

#### 解决方案
* 在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降
* 热点数据缓存永远不过期。

### 穿透
#### 穿透概念
缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。
如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。

#### 为什么会发生穿透
缓存穿透的关键在于在Redis中查不到key值，它和缓存击穿的根本区别在于传进来的key在Redis中是不存在的。
假如有黑客传进大量的不存在的key，那么大量的请求打在数据库上是很致命的问题，
所以在日常开发中要对参数做好校验，一些非法的参数，不可能存在的key就直接返回错误提示。

#### 解决方案
* 将无效的key存放进Redis中：
当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=“null”，并设置其过期时间极短，
后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。
但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。
* 使用布隆过滤器：
如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。
于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，
在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。

#### 如何选择解决方案
针对一些恶意攻击，攻击带过来的大量key是随机，那么我们采用第一种方案就会缓存大量不存在key的数据。
那么这种方案就不合适了，我们可以先对使用布隆过滤器方案进行过滤掉这些key。
所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。
而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。

### Redis集群
Redis 3.0加入了Redis的集群模式，实现了数据的分布式存储，
对数据进行分片，将不同的数据存储在不同的master节点上面，从而解决了海量数据的存储问题。

#### 集群的搭建
1. 启动节点：将节点以集群方式启动，此时节点是独立的。
2. 节点握手：将独立的节点连成网络。
3. 槽指派：将16384个槽位分配给主节点，以达到分片保存数据库键值对的效果。
4. 主从复制：为从节点指定主节点。

#### 为什么需要Redis集群
在讲Redis集群架构之前，我们先简单讲下Redis单实例的架构，从最开始的一主N从，到读写分离，再到Sentinel哨兵机制，
单实例的Redis缓存足以应对大多数的使用场景，也能实现主从故障迁移。
但是，在某些场景下，单实例存Redis缓存会存在的几个问题：
1. 写并发：
   Redis单实例读写分离可以解决读操作的负载均衡，但对于写操作，仍然是全部落在了master节点上面，
   在海量数据高并发场景，一个节点写数据容易出现瓶颈，造成master节点的压力上升。
2. 海量数据的存储压力：
   单实例Redis本质上只有一台Master作为存储，如果面对海量数据的存储，一台Redis的服务器就应付不过来了，
   而且数据量太大意味着持久化成本高，严重时可能会阻塞服务器，造成服务请求成功率下降，降低服务的稳定性。

针对以上的问题，Redis集群提供了较为完善的方案，解决了存储能力受到单机限制，写操作无法负载均衡的问题。

#### Redis集群中节点的通信机制
gossip协议

#### Redis集群的数据分布算法
Redis集群采用的算法是哈希槽分区算法。Redis集群中有16384个哈希槽（槽的范围是 0 -16383，哈希槽），
将不同的哈希槽分布在不同的Redis节点上面进行管理，也就是说每个Redis节点只负责一部分的哈希槽。
在对数据进行操作的时候，集群会对使用CRC16算法对key进行计算并对16384取模（slot = CRC16(key)%16383），
得到的结果就是 Key-Value 所放入的槽，通过这个值，去找到对应的槽所对应的Redis节点，然后直接到这个对应的节点上进行存取操作。

#### 使用哈希槽的好处
使用哈希槽的好处就在于可以方便的添加或者移除节点，并且无论是添加删除或者修改某一个节点，都不会造成集群不可用的状态。
当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；
当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；
哈希槽数据分区算法具有以下几种特点：
1. 解耦数据和节点之间的关系，简化了扩容和收缩难度；
2. 节点自身维护槽的映射关系，不需要客户端代理服务维护槽分区元数据
3. 支持节点、槽、键之间的映射查询，用于数据路由，在线伸缩等场景

#### 槽的迁移与指派命令
CLUSTER ADDSLOTS 0 1 2 3 4 … 5000

#### 集群扩容
* 启动新节点
* 使用cluster meet命令将新节点加入到集群
* 迁移槽和数据：添加新节点后，需要将一些槽和数据从旧节点迁移到新节点

#### 集群收缩
* 迁移槽。
* 忘记节点。通过命令 cluster forget {downNodeId} 通知其他的节点

### 哨兵机制
#### 什么是哨兵模式
在主从模式下（主从模式就是把所有哨兵去掉），master节点负责写请求，然后异步同步给slave节点，从节点负责处理读请求。
如果master宕机了，需要手动将从节点晋升为主节点，并且还要切换客户端的连接数据源。
这就无法达到**高可用**，而通过哨兵模式就可以解决这一问题。

**哨兵模式是Redis的高可用方式**，哨兵节点是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。
哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过sentinel代理访问redis的主节点，
当redis的主节点挂掉时，哨兵会第一时间感知到，并且在slave节点中重新选出来一个新的master，然后将新的master信息通知给client端，从而实现高可用。
这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息。

#### 哨兵的主要工作任务
* 监控：哨兵会不断地检查你的Master和Slave是否运作正常。
* 提醒：当被监控的某个Redis节点出现问题时，哨兵可以通过 API 向管理员或者其他应用程序发送通知。
* 自动故障迁移：当一个Master不能正常工作时，哨兵会进行自动故障迁移操作，
  将失效Master的其中一个Slave升级为新的Master，并让失效Master的其他Slave改为复制新的Master；
  当客户端试图连接失效的Master时，集群也会向客户端返回新Master的地址，使得集群可以使用新Master代替失效Master。

#### 哨兵模式搭建
1. 配置sentinel.conf文件，配件需要监听的主从的master节点
2. 如果主从master设置了密码，还需要配置
3. 修改心跳检测的主观下线时间
4. 从服务器的个数配置
5. 启动指定的哨兵配置文件启动哨兵
6. 查看状态信息。配置完之后，进入./redis-cli，输入info命令，查看哨兵的状态信息
7. Java客户端连接哨兵模式，只需要配置哨兵节点即可

#### 哨兵模式的工作原理
1. 心跳机制
2. 判断master节点是否下线
3. 基于Raft算法选举领头sentinel
4. 故障转移
5. 修改配置

